<!DOCTYPE html>
<html lang="en">
<head>
  <script src="data.json"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TrackersInfo Route Planner</title>
  <link rel="stylesheet" href="styles.css">
  <style>
    /* Announcement modal styles */
    #site-announcement-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #site-announcement {
      background: #fff;
      color: #111;
      max-width: 720px;
      width: calc(100% - 40px);
      border-radius: 10px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.25);
      padding: 20px 22px;
      font-size: 15px;
      line-height: 1.4;
      box-sizing: border-box;
      position: relative;
    }
    #site-announcement h2 { margin: 0 0 8px 0; font-size: 18px; }
    #site-announcement .announcement-actions { margin-top: 14px; display:flex; gap:8px; justify-content:flex-end; }
    #site-announcement .btn { background:#0b69ff; color:#fff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer; font-weight:600; }
    #site-announcement .btn.secondary { background: #eee; color:#111; }
    #site-announcement .close-x { position:absolute; right:12px; top:10px; background:transparent; border:none; font-size:20px; cursor:pointer; }
  </style>
</head>
<body>
  <!-- Announcement modal -->
  <div id="site-announcement-overlay" style="display:none">
    <div id="site-announcement" role="dialog" aria-labelledby="site-announcement-title">
      <button class="close-x" aria-label="Close announcement">×</button>
      <h2 id="site-announcement-title">invite.icu is no longer maintained</h2>
      <div class="announcement-body">
        <p>This repo was initiated to fill the gap left by 'the graph'. With the arrival of a better alternative, this repository is no longer necessary. I recommend deferring to the more professional solution provided by Tracker Pathways. It offers a smarter, more user-friendly experience. I think you'll love it: <a href="https://trackerpathways.org/" target="_blank" rel="noopener noreferrer">https://trackerpathways.org/</a></p>
        <label style="display:flex; align-items:center; gap:8px; margin-top:10px; font-size:13px;">
          <input type="checkbox" id="announcement-dontshow" />
          <span>Don't show again</span>
        </label>
      </div>
      <div class="announcement-actions">
        <button class="btn secondary" id="announcement-close">Close</button>
        <button class="btn" id="announcement-open">Open Link</button>
      </div>
    </div>
  </div>

  <script>
    // Show announcement on page load and wire up controls
    window.addEventListener('load', function() {
      try {
        var overlay = document.getElementById('site-announcement-overlay');
        var closeBtn = document.getElementById('announcement-close');
        var openBtn = document.getElementById('announcement-open');
        var closeX = document.querySelector('#site-announcement .close-x');
        var dontShowCheckbox = document.getElementById('announcement-dontshow');
        var storageKey = 'siteAnnouncementDismissed_v1';

        if (!overlay) return;

        // If user previously dismissed, do not show
        try {
          if (window.localStorage && window.localStorage.getItem(storageKey) === '1') {
            return; // do not show
          }
        } catch (e) {
          // localStorage may be disabled, continue to show
        }

        // Show the modal
        overlay.style.display = 'flex';

        // Close handlers
        function hide() {
          // remember preference if checked
          try {
            if (dontShowCheckbox && dontShowCheckbox.checked && window.localStorage) {
              window.localStorage.setItem(storageKey, '1');
            }
          } catch (e) {
            // ignore storage errors
          }
          overlay.style.display = 'none';
        }

        closeBtn && closeBtn.addEventListener('click', hide);
        closeX && closeX.addEventListener('click', hide);
        overlay.addEventListener('click', function(e){ if (e.target === overlay) hide(); });

        openBtn && openBtn.addEventListener('click', function(){
          // If user has checked "don't show" and opens the link, still remember preference
          try {
            if (dontShowCheckbox && dontShowCheckbox.checked && window.localStorage) {
              window.localStorage.setItem(storageKey, '1');
            }
          } catch (e) {}
          window.open('https://trackerpathways.org/', '_blank', 'noopener');
        });
      } catch (err) {
        console.warn('Announcement failed to initialize', err);
      }
    });
  </script>
  <form id="routeContainer" style="display: block;">
    <div id="calcForm">
      <table id="headerTable">
        <tr>
          <td class="col2" colspan="3" style="vertical-align: top; padding: 5px;"> 
            <div style="margin-bottom: 10px;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <div style="flex: 1;">
                  <div id="source-token-wrapper" style="display: flex; align-items: center; flex-wrap: wrap; gap: 6px; width: 100%; box-sizing: border-box; border: 1px solid #ccc; padding: 6px 8px; border-radius: 4px;">
                    <div id="selected-sources-container" style="display: flex; align-items: center; gap: 5px; flex-wrap: wrap;"></div>
                    <input type="text" id="source" placeholder="Source Tracker(s)" autocomplete="off" list="source-list" style="flex: 1; min-width: 120px; border: none; outline: none; font-size: 14px; padding: 6px; background: transparent;">
                  </div>
                </div>
                <button type="button" id="clear-source" aria-label="Clear source" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #888; padding: 8px 12px; min-width: 40px; border-radius: 6px;">×</button>
              </div>
              <datalist id="source-list"></datalist>
            </div>
            <div>
               <div style="display: flex; align-items: center; gap: 8px;">
                 <div style="flex: 1;">
                   <div id="target-token-wrapper" style="display: flex; align-items: center; flex-wrap: wrap; gap: 6px; width: 100%; box-sizing: border-box; border: 1px solid #ccc; padding: 6px 8px; border-radius: 4px;">
                     <div id="selected-targets-container" style="display: flex; align-items: center; gap: 5px; flex-wrap: wrap;"></div>
                     <input type="text" id="target" placeholder="Target Tracker(s)" autocomplete="off" list="target-list" style="flex: 1; min-width: 120px; border: none; outline: none; font-size: 14px; padding: 6px; background: transparent;">
                   </div>
                 </div>
                 <button type="button" id="clear-target" aria-label="Clear target" style="background: none; border: none; cursor: pointer; font-size: 18px; color: #888; padding: 8px 12px; min-width: 40px; border-radius: 6px;">×</button>
               </div>
               <datalist id="target-list"></datalist>
            </div>
          </td>
        </tr>
      </table>

      <div class="inline-settings-container">
        
        <div class="settings-section">
          <div class="settings-header">Route Options</div>
          <div class="settings-options">
            
            <div class="settings-option-item radio-group">
              <label>Max Jumps</label>
              <div class="radio-options">
                <label class="radio-option">
                  <input type="radio" name="maxJumps" value="1"> 1
                </label>
                <label class="radio-option">
                  <input type="radio" name="maxJumps" value="4" checked> 4
                </label>
                <label class="radio-option">
                  <input type="radio" name="maxJumps" value="9"> 9
                </label>
              </div>
            </div>

            <div class="settings-option-item radio-group">
              <label>Max Days</label>
              <div class="radio-options">
                <label class="radio-option">
                  <input type="radio" name="maxDays" value="365"> 1y
                </label>
                <label class="radio-option">
                  <input type="radio" name="maxDays" value="730" checked> 2y
                </label>
                <label class="radio-option">
                  <input type="radio" name="maxDays" value="1095"> 3y
                </label>
                <label class="radio-option">
                  <input type="radio" name="maxDays" value="1825"> 5y
                </label>
              </div>
            </div>
            <div class="settings-option-item radio-group">
              <label>Sort By</label>
               <div class="radio-options">
                <label class="radio-option">
                  <input type="radio" name="sortOption" value="fastest" checked> Days
                </label>
                <label class="radio-option">
                  <input type="radio" name="sortOption" value="fewestJumps"> Jumps
                </label>
              </div>
            </div>
          </div>
        </div>

      </div> 

      <div id="detailsTable"></div>
    </div>
  </form>
      <div id="bottom-info-container" style="position: fixed; bottom: 0.5em; right: 0.5em; display: flex; flex-direction: row; align-items: center; gap: 8px; font-size: 13px; z-index: 1000; background: rgba(255,255,255,0.95); padding: 6px 8px; border-radius: 6px; max-width: calc(100% - 2rem); box-sizing: border-box;">
        <p id="update-time" style="margin: 0; white-space: nowrap; overflow-wrap: anywhere; flex: 0 0 auto;">Last updated Loading...</p>
        <div style="display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; flex: 1 1 auto;">
          <a href="https://www.reddit.com/r/TrackersInfo/wiki/official_recruitments/">TrackersInfo</a>
          <a href="https://github.com/ti-or/ti-or.github.io">GitHub</a>
        </div>
      </div>
  <script>

  window.addEventListener('load', function() {

    const validMaxDaysValues = [365, 730, 1095, 1825];
    const defaultMaxDays = 730;
    const validMaxJumpsValues = [1, 4, 9];
    const defaultMaxJumps = 4;
    const validSortOptionValues = ['fastest', 'fewestJumps'];
    const defaultSortOption = 'fastest';

    let activeRouteIndex = 0; 
    let maxJumps = defaultMaxJumps;
    let maxDays = defaultMaxDays;
    let sortOptionValue = defaultSortOption;

    const sourceInput = document.getElementById('source');
    const targetInput = document.getElementById('target');
    const routeForm = document.getElementById('routeContainer');
    if (routeForm) {
      routeForm.addEventListener('submit', (e) => {
        e.preventDefault();
      });
    }

    // helper: find top datalist option matching current input
    function getTopDatalistMatch(inputEl, datalistId) {
      const list = document.getElementById(datalistId);
      if (!list) return null;
      const val = inputEl.value.trim().toLowerCase();
      if (!val) return null;
      for (const opt of list.options) {
        if (!opt.value) continue;
        const optVal = opt.value.toLowerCase();
        if (optVal.startsWith(val)) return opt.value;
      }
      // fallback: return first option that contains the input
      for (const opt of list.options) {
        if (!opt.value) continue;
        const optVal = opt.value.toLowerCase();
        if (optVal.includes(val)) return opt.value;
      }
      return null;
    }

    targetInput.addEventListener('keydown', (e) => {
      if (e.isComposing) return; // ignore IME composition
      
      // Enter key is now handled by the 'change' event when the input is focused but not explicitly submitted (like Space)
      // We will keep Enter for immediate calculation, but for multi-select, 'Space' or 'change' is the primary way to select.
      if (e.key === 'Enter') {
        e.preventDefault();
        // If there's text, treat it as selection via change handler, otherwise just calculate with current selections
        if (targetInput.value.trim() !== '') {
          targetInput.dispatchEvent(new Event('change'));
        } else {
          calculateRoute();
        }
        return;
      }
      
      // Space selects top datalist suggestion for target
      if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
        const match = getTopDatalistMatch(targetInput, 'target-list');
        if (match) {
          e.preventDefault();
          const cleaned = match.replace(/\s*\([^)]*\)/g, '');
          if (!selectedTargets.includes(cleaned)) {
            selectedTargets.push(cleaned);
            renderSelectedTargets();
            targetInput.value = '';
            calculateRoute();
          } else {
            targetInput.value = '';
          }
        }
        return;
      }

      if (e.key === 'Delete') {
        e.preventDefault();
        targetInput.value = '';
        if (selectedTargets.length > 0) {
          selectedTargets = [];
          renderSelectedTargets();
          calculateRoute();
        }
        return;
      }

      if (e.key === 'Backspace' && targetInput.value.trim() === '') {
        e.preventDefault();
        if (selectedTargets.length > 0) {
          selectedTargets.pop();
          renderSelectedTargets();
          calculateRoute();
        }
      }
    });

    sourceInput.addEventListener('keydown', (e) => {
      if (e.isComposing) return; // ignore IME composition

      // Space selects top datalist suggestion for source
      if (e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar') {
        const match = getTopDatalistMatch(sourceInput, 'source-list');
        if (match) {
          e.preventDefault();
          const cleaned = match.replace(/\s*\([^)]*\)/g, '');
          if (!selectedSources.includes(cleaned)) {
            selectedSources.push(cleaned);
            renderSelectedSources();
            sourceInput.value = '';
            calculateRoute();
          } else {
            sourceInput.value = '';
          }
        }
        return;
      }

      if (e.key === 'Delete') {
        e.preventDefault();
        sourceInput.value = '';
        if (selectedSources.length > 0) {
          selectedSources = [];
          renderSelectedSources();
          calculateRoute();
        }
        return;
      }

      if (e.key === 'Backspace' && sourceInput.value.trim() === '') {
        e.preventDefault();
        if (selectedSources.length > 0) {
          selectedSources.pop();
          renderSelectedSources();
          calculateRoute();
        }
      }
    });

    const { routeInfo, unlockInviteClass, abbrList } = data;
    let allRoutes = [];
    let selectedSources = [];
    let selectedTargets = []; // New state variable
    const selectedSourcesContainer = document.getElementById('selected-sources-container');
    const selectedTargetsContainer = document.getElementById('selected-targets-container'); // New container reference

    function renderSelectedSources() {
        selectedSourcesContainer.innerHTML = '';
        selectedSources.forEach(source => {
            const sourceElement = document.createElement('span');
            sourceElement.className = 'selected-source-tag';
            sourceElement.innerHTML = `${abbrList[source] ? `${source} (${abbrList[source]})` : source} <button type="button" data-source="${source}">×</button>`;
            selectedSourcesContainer.appendChild(sourceElement);
            sourceElement.querySelector('button').addEventListener('click', (e) => {
                const sourceToRemove = e.target.dataset.source;
                selectedSources = selectedSources.filter(s => s !== sourceToRemove);
                renderSelectedSources();
                calculateRoute();
            });
        });

        // Hide placeholder if items are selected
        if (selectedSources.length > 0) {
            sourceInput.placeholder = '';
        } else {
            sourceInput.placeholder = 'Source Tracker(s)';
        }
    }

    // New rendering function for targets
    function renderSelectedTargets() {
        selectedTargetsContainer.innerHTML = '';
        selectedTargets.forEach(target => {
            const targetElement = document.createElement('span');
            targetElement.className = 'selected-source-tag'; // Reuse style
            targetElement.innerHTML = `${abbrList[target] ? `${target} (${abbrList[target]})` : target} <button type="button" data-target="${target}">×</button>`;
            selectedTargetsContainer.appendChild(targetElement);
            targetElement.querySelector('button').addEventListener('click', (e) => {
                const targetToRemove = e.target.dataset.target;
                selectedTargets = selectedTargets.filter(t => t !== targetToRemove);
                renderSelectedTargets();
                calculateRoute();
            });
        });

        // Hide placeholder if items are selected
        if (selectedTargets.length > 0) {
            targetInput.placeholder = '';
        } else {
            targetInput.placeholder = 'Target Tracker(s)';
        }
    }

    function getLastUpdatedMonth() {
        let lastUpdated = "Loading...";
        let latestDate = new Date(0);
        for (const tracker in routeInfo) {
            for (const dest in routeInfo[tracker]) {
                const dateString = routeInfo[tracker][dest][2];
                if (dateString) {
                    const parts = dateString.split(' ');
                    const month = parts[0];
                    const year = parseInt(parts[1]);
                    const date = new Date(`${month} 01, ${year}`);

                    if (!isNaN(date.getTime()) && date > latestDate) {
                        latestDate = date;
                        lastUpdated = `${month} ${year}`;
                    }
                }
            }
        }
        return lastUpdated;
    }
   const updateTimeElement = document.getElementById('update-time');
   updateTimeElement.textContent = `Last updated ${getLastUpdatedMonth()}`;

    function populateDatalists() {
        const sourceList = document.getElementById('source-list');
        const targetList = document.getElementById('target-list');
        sourceList.innerHTML = '';
        targetList.innerHTML = '';

      const uniqueKeys = Array.from(new Set(
        Object.keys(routeInfo)
        .flatMap(startKey => [startKey, ...Object.keys(routeInfo[startKey])])
      ))
      .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));

        uniqueKeys.forEach(key => {
            const option = document.createElement('option');
            option.value = abbrList[key] ? key + ' (' + abbrList[key] + ')' : key + ' (' + key + ')';
            if (key in routeInfo) sourceList.appendChild(option.cloneNode(true));
            targetList.appendChild(option);
           });
           console.log("Datalists populated.");
    }

    function getMaxDays(start, end) {
      const days1 = (routeInfo[start] && routeInfo[start][end] && routeInfo[start][end][0]) || 0;
      const days2 = (unlockInviteClass[start] && unlockInviteClass[start][0]) || 0;
      return Math.max(days1, days2);
    }

    function findAllRoutes(start, end, maxJumps, maxDays) {
      const result = [];
      const stack = [[start, [start], 0]];
      while (stack.length) {
        const [node, route, days] = stack.pop();
        if (route.length > maxJumps + 1 || days > maxDays) continue;
        if (node === end) {
          result.push(route);
          continue;
        }
        for (const [next, _] of Object.entries(routeInfo[node] || {})) {
          const maxDaysToNext = getMaxDays(node, next);
          if (!route.includes(next) && (days + maxDaysToNext) <= maxDays) {
            stack.push([next, [...route, next], days + maxDaysToNext]);
          }
        }
      }
      return result;
    }

    function showPage(routes, currentPage, activeRouteIndex) {
        const pageSize = 5;
        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = Math.min(startIndex + pageSize, routes.length);
        const totalPages = Math.ceil(routes.length / pageSize);
        const resultDescription = document.getElementById('detailsTable');
        
        let routesHTML = '';
        for (let i = startIndex; i < endIndex; i++) {
            const route = routes[i];
          const totalDays = route.reduce((sum, node, index) => {
            if (index < route.length - 1 && routeInfo[node] && routeInfo[node][route[index + 1]]) {
              return sum + getMaxDays(node, route[index + 1]);
            }
            return sum;
          }, 0);
            const jumps = route.length - 1; 
            const isActiveClass = i === activeRouteIndex ? 'active' : ''; 

          routesHTML += `
            <div class="block route">
                <div class="route-header ${isActiveClass}" data-route-index="${i}"> 
                  <span class="route-number-label">Route ${i + 1}</span>
                  <span class="route-time-display">
                    <span class="route-label time-label">Days</span> ${totalDays} 
                      </span>
                  <span class="route-changes-display">
                    <span class="route-label changes-label">Jumps</span> ${jumps}</span>
                    </div>
                <div class="block_content"> 
                <div class="dtl">
          `;
          let cumulativeDays = 0;
          route.forEach((node, index) => {
            const isLast = index === route.length - 1;
            const isFirst = index === 0;
            cumulativeDays += (isFirst ? 0 : getMaxDays(route[index-1] || '', node) || 0);
            routesHTML += `
              <div class="row sta${isFirst ? ' from' : isLast ? ' to' : ''}">
                <div class="tbl">
                     <div class="col border"></div>
                  <div class="col wrapper">
                    <div class="tbl">
                      <div class="col header">
                           <div class="time">Day ${cumulativeDays}</div>
                        <div class="name">
                          <p class="lang_main">${abbrList[node] ? `${node} (${abbrList[node]})` : node}</p>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            `;

            if (!isLast && routeInfo[node] && routeInfo[node][route[index + 1]]) {
              const Node = route[index];
              const nextNode = route[index + 1];
              const [time, requirement, lastActivity] = routeInfo[node][nextNode];
                 const inviteReq = unlockInviteClass[node] ? unlockInviteClass[node][1] : 'N/A';
              routesHTML += `
                <div class="row line">
                  <div class="tbl">
                    <div class="col border">
                         <div class="timeline-line full-height" style="background-color: #009BBF;"></div> 
                    </div>
                    <div class="col wrapper">
                      <div class="tbl">
                        <div class="col content">
                          <p class="tra">
                               From ${Node} to ${nextNode}
                          </p>
                        </div>
                        <div class="col aside">${getMaxDays(node, nextNode)} days</div>
                      </div>
                         <div class="fare">
                           <p>Requirements: ${requirement || 'None'}</p>
                           <p>Class for invite forum: ${inviteReq}</p>
                           <p class="lang_sub">Last checked: ${lastActivity}</p>
                         </div>
                    </div>
                  </div>
                </div>
              `;
            }
          });
           routesHTML += `</div></div></div>`;
        }

        const paginationHTML = `
          <div class="pagination block" style="padding: 10px; text-align: center;">
            ${currentPage > 1 ? `<button class="page-btn" style="margin: 5px;" data-page="1">&lt;&lt;</button>` : ''}
            ${currentPage > 1 ? `<button class="page-btn" style="margin: 5px;" data-page="${currentPage - 1}">&lt;</button>` : ''}
            ${
              Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                let startPage = Math.max(1, currentPage - 2);
                if (startPage + 4 > totalPages) {
                  startPage = Math.max(1, totalPages - 4);
                }
                const page = startPage + i;
                return `<button class="page-btn" style="margin: 5px;" data-page="${page}">${page}</button>`;
              }).join('')
            }
            ${currentPage < totalPages ? `<button class="page-btn" style="margin: 5px;" data-page="${currentPage + 1}">&gt;</button>` : ''}
            ${currentPage < totalPages ? `<button class="page-btn" style="margin: 5px;" data-page="${totalPages}">&gt;&gt;</button>` : ''}
          </div>
        `;
        resultDescription.innerHTML = routesHTML + paginationHTML;

        resultDescription.querySelectorAll('.page-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const newPage = parseInt(e.target.dataset.page);
            if (newPage !== currentPage) {
              showPage(allRoutes, newPage, activeRouteIndex);
              window.scrollTo(0, 0);
            }
          });
        });

        resultDescription.querySelectorAll('.route-header').forEach(header => {
            header.addEventListener('click', (event) => {
                const newActiveIndex = parseInt(header.dataset.routeIndex, 10);
                if (activeRouteIndex !== newActiveIndex) {
                    activeRouteIndex = newActiveIndex;
                    document.querySelectorAll('.route-header.active').forEach(el => el.classList.remove('active'));
                    header.classList.add('active');
            }
          });
        });
      }

    function calculateRouteTotalDays(route) {
        let totalDays = 0;
        for (let i = 0; i < route.length - 1; i++) {
            totalDays += getMaxDays(route[i], route[i+1]);
        }
        return totalDays;
    }

    function calculateRoute() {
      const resultDescription = document.getElementById('detailsTable');
      resultDescription.innerHTML = '';

      // targetInput.value is only for suggestion/autofill, the actual targets are in selectedTargets
      // const target = targetInput.value.trim().replace(/\s*\([^)]*\)/g, ''); // OBSOLETE

      console.log(`Calculating routes from ${selectedSources.length} sources to ${selectedTargets.length} targets`);
      const currentSortOption = document.querySelector('input[name="sortOption"]:checked').value;
      console.log(`Sorting by: ${currentSortOption}`);

      // Case 1: Neither Source(s) nor Target(s) are selected
      if (selectedSources.length === 0 && selectedTargets.length === 0) {
          resultDescription.innerHTML = '';
          allRoutes = [];
          return;
      }
      
      let combinedRoutes = [];
      const trackers = Object.keys(routeInfo);
      
      // Case 2: Only Target(s) selected (one-jump search)
      if (selectedSources.length === 0 && selectedTargets.length > 0) {
        selectedTargets.forEach(target => {
          const reachableTrackers = trackers
            .filter(source => routeInfo[source] && routeInfo[source][target]);
            
          reachableTrackers.forEach(source => {
             // For one-jump routes, we just construct the array
             combinedRoutes.push([source, target]);
          });
        });
      }
      
      // Case 3: Both Source(s) and Target(s) selected (multi-jump search)
      if (selectedSources.length > 0 && selectedTargets.length > 0) {
        selectedSources.forEach(source => {
          selectedTargets.forEach(target => {
            if (source === target) {
              return;
            }
            if (!routeInfo[source] && !trackers.includes(source)) {
                // console.log(`Source tracker "${source}" not found or has no routes.`);
                return;
            }
            // Check if target is a known tracker (either as source or destination)
            const isTargetKnown = trackers.includes(target) || trackers.some(sourceKey => routeInfo[sourceKey] && routeInfo[sourceKey][target]);
            if (!isTargetKnown) {
                // console.log(`Target tracker "${target}" not found in route data.`);
                return;
            }

            const routesFromSourceToTarget = findAllRoutes(source, target, maxJumps, maxDays);
            combinedRoutes = combinedRoutes.concat(routesFromSourceToTarget);
          });
        });
      }

      // Case 4: Only Source(s) selected (show all one-jump routes from sources)
      if (selectedSources.length > 0 && selectedTargets.length === 0) {
        selectedSources.forEach(source => {
          if (routeInfo[source]) {
            const directTargets = Object.keys(routeInfo[source]);
            directTargets.forEach(target => {
              combinedRoutes.push([source, target]);
            });
          }
        });
      }

      // Case 5: Target(s) selected but no routes found
      if (combinedRoutes.length === 0 && selectedSources.length === 0 && selectedTargets.length > 0) {
         resultDescription.innerHTML = `<div class="status-message">No routes found to the selected Target Tracker(s).</div>`;
         allRoutes = [];
         return;
      }
      
      allRoutes = combinedRoutes;

      if (allRoutes.length === 0) {
          resultDescription.innerHTML = '<div class="status-message">No results found</div>';
          return;
      }
      
      // Sorting Logic (Moved outside conditional blocks)
      if (currentSortOption === 'fastest') {
          allRoutes.sort((routeA, routeB) => {
              const daysA = calculateRouteTotalDays(routeA);
              const daysB = calculateRouteTotalDays(routeB);
              if (daysA !== daysB) {
                  return daysA - daysB;
              }
              return routeA.length - routeB.length;
          });
      } else if (currentSortOption === 'fewestJumps') {
          allRoutes.sort((routeA, routeB) => {
              if (routeA.length !== routeB.length) {
                  return routeA.length - routeB.length;
              }
              const daysA = calculateRouteTotalDays(routeA);
              const daysB = calculateRouteTotalDays(routeB);
              return daysA - daysB;
          });
      }

      activeRouteIndex = 0;
      showPage(allRoutes, 1, activeRouteIndex);
      return;
    }

    try {
    } catch (e) {
        console.error("Error during initial radio state setting:", e);
    }
    
    populateDatalists();

    const savedSource = null;
    const savedTarget = null;

    document.querySelectorAll('input[name="maxJumps"]').forEach(radio => { 
        radio.addEventListener('change', (e) => {
            maxJumps = parseInt(e.target.value, 10); 
            calculateRoute();
        }); 
    });
    document.querySelectorAll('input[name="maxDays"]').forEach(radio => { 
        radio.addEventListener('change', (e) => {
            maxDays = parseInt(e.target.value, 10); 
            calculateRoute();
        }); 
    });
    document.querySelectorAll('input[name="sortOption"]').forEach(radio => { 
        radio.addEventListener('change', (e) => {
            sortOptionValue = e.target.value; 
            calculateRoute();
        }); 
    });
    
    sourceInput.addEventListener('change', () => {
      const selectedValue = sourceInput.value.trim().replace(/\s*\([^)]*\)/g, '');
      console.log(`Change detected on sourceInput. Selected value: "${selectedValue}"`);

      if (selectedValue === '') {
        // nothing selected
        sourceInput.value = '';
        return;
      }

      if (selectedSources.includes(selectedValue)) {
        // already selected, just clear the input
        sourceInput.value = '';
        return;
      }

      // Accept the selected value even if it's not a starting key in routeInfo
      selectedSources.push(selectedValue);
      renderSelectedSources();
      sourceInput.value = '';
      calculateRoute();
    });

    targetInput.addEventListener('change', () => {
      const selectedValue = targetInput.value.trim().replace(/\s*\([^)]*\)/g, '');
      console.log(`Change detected on targetInput. Selected value: "${selectedValue}"`);

      if (selectedValue === '') {
        // nothing selected
        targetInput.value = '';
        return;
      }

      if (selectedTargets.includes(selectedValue)) {
        // already selected, just clear the input
        targetInput.value = '';
        return;
      }

      // Accept the selected value even if it's not a starting key in routeInfo
      selectedTargets.push(selectedValue);
      renderSelectedTargets();
      targetInput.value = '';
      calculateRoute();
    });

    document.getElementById('clear-source').addEventListener('click', () => {
        sourceInput.value = '';
        selectedSources = [];
        renderSelectedSources();
        calculateRoute();
    });

    document.getElementById('clear-target').addEventListener('click', () => {
        targetInput.value = '';
        selectedTargets = [];
        renderSelectedTargets();
        calculateRoute();
    });

    calculateRoute(); 
  });
  </script>
  <script data-goatcounter="https://98et5e.goatcounter.com/count"
  async src="//gc.zgo.at/count.js"></script>
</body>
</html>

